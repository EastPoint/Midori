$script:nuget = $null

function Get-CurrentDirectory
{
  $thisName = $MyInvocation.MyCommand.Name
  [IO.Path]::GetDirectoryName((Get-Content function:$thisName).File)
}

function Get-NugetPath
{
  if ($script:nuget -and (Test-Path -IsValid $script:nuget) -and `
    (Test-Path $script:nuget))
  {
    return $script:nuget
  }

  $params = @{
    Path = Get-CurrentDirectory;
    Include = 'nuget.exe';
    Recurse = $true;
  }

  $script:nuget = Get-ChildItem @params |
    Select -ExpandProperty FullName -First 1
  return $script:nuget
}

function Restore-Nuget
{
  Write-Verbose 'Restore-Nuget'
  $firstTime = $script:nuget -eq $null
  $nuget = Get-NugetPath

  if ($firstTime -and ($nuget -ne $null))
  {
    &"$nuget" update -Self | Write-Host
    return
  }

  $nugetPath = Join-Path (Get-CurrentDirectory) 'nuget.exe'
  (New-Object Net.WebClient).DownloadFile('http://nuget.org/NuGet.exe', $nugetPath)

  $script:nuget = $nugetPath
}

function Find-NuGetPackages
{
<#
.Synopsis
  Will use the NuGet 'list' command to search for packages of the given
  Name at the given Source (if specified).
.Description
  Nothing fancy here, aside from a light wrapper around Nuget list
  that properly handles generating a search and parsing the results into
  a Hashtable.

  Special treatment is currently given to MyGet feeds specified as a
  source as there is a bug preventing multiple search terms from being
  properly processed on the server.  For a specified MyGet feed, the
  full list is generated by the server, and filtered client-side.

  Note that the MyGet work-around only applies when MyGet is specified
  as the source, not when it is queried implictly based on being
  configured in local sources.

  The client-side is filtered to ensure that the packages returned
  contain the Name(s) specified.
.Parameter Name
  The list of package names to search for in the remote feed.

  Note that the Name is not considered exact, but a substring value.
.Parameter Source
  The remote feed to search against instead of the defaults.

  Note that MyGet is given special treatment if more than one Name is
  specified.
.Example
  Find-NuGetPackages -Name 'CroMagVersion', 'Midori'

  Description
  -----------
  Will search the default Nuget feeds, returning a Hashtable with the
  latest versions of CroMagVersion and Midori.

  May return additional packages based on how the server executes the
  search.
.Example
  Find-NuGetPackages -Name 'CroMagVersion', 'Midori' `
    - 'https://www.myget.org/F/YOURGUID/'

  Description
  -----------
  Will search the given MyGet feed, returning a Hashtable with the
  latest versions of CroMagVersion and Midori should they exist.

  May return additional packages based on how the server executes the
  search.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string[]]
    $Name,

    [Parameter(Mandatory = $false)]
    [string]
    $Source
  )

  Write-Verbose "Find-NuGetPackages retrieving package list from $source..."

  Restore-Nuget

  # TODO: handle -Prerelease
  $listArgs = @()
  if (![string]::IsNullOrEmpty($source)) { $listArgs += '-Source', $source }

  # HACK: myget bug doesn't return search results for multiple pkgs
  # TODO: remove the myget check once they fix their bug
  if ($Name -and ($Name.Length -gt 1) -and ($source -notmatch 'myget\.org'))
    { $listArgs += ($Name -join ', ') }

  $listArgs += '-NonInteractive'

  $list = &$script:nuget list $listArgs
  $packages = @{}
  $list |
    ? { ($_ -notmatch '^(Using credentials)|(No packages)') } |
    % {
      $packageDef = $_ -split '\s'
      $id = $packageDef[0]
      if ($Name)
      {
        $match = $false
        $Name |
          % { if (!$match) { $match = $id -match $_ } }

        if ($match) { $packages.$id = $packageDef[1] }
      }
    }

  Write-Host "Found $($packages.Count) packages at $source"
  return $packages
}

function Get-NuGetPackageSpecs
{
<#
.Synopsis
  Will find all the specified Nuspec files recursively within a
  particular given Path, and will load their Xml specs into a Hashtable.
.Description
  The Nuspec files are read as Xml, and the 'id' of the package is used
  as the key in the Hashtable.

  There are a couple of caveats here.

  If the metadata id field of the package is set to resolve at build
  time based on a local csproj using the '$id$' identifier, then the
  NuGet 'pack' command is run against the csproj to produce a .nupkg
  file.  This file is then used to determine the id and version fields
  and the loaded Xml is modified accordingly.

  This requires that the project has been previously built once.  If it
  has not, then the 'pack' command cannot be run, and the given .nuspec
  will *not* be added to the returned Hashtable.
.Parameter Path
  The optional path fed to Get-ChildItem, that will be used to recurse a given
  directory structure.

  If left unspecified, the current directory is searched.
.Example
  Get-NuGetPackageSpecs

  Description
  -----------
  Assuming there are .nuspec files found recursively, the resulting
  Hashtable will be similar to the following

  Name                           Value
  ----                           -----
  Midori                         {Path, Definition}

.Example
  Get-NuGetPackageSpecs -Path c:\source

  Description
  -----------
  Will search c:\source recursively for .nuspec files, building a
  Hashtable with any found .nuspec files.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $false)]
    [string]
    [ValidateScript({ (Get-Item $_).PSIsContainer })]
    $Path = (Get-Item .),

    [Parameter(Mandatory = $false)]
    [string[]]
    $Include = '*.nuspec'
  )
  Write-Verbose "Get-NuGetPackageSpecs running against $Path for $Include"

  $specs = @{}

  Get-ChildItem -Path $Path -Include $Include -Recurse |
    ? { (Split-Path $_.DirectoryName -Leaf) -ne 'packages' } |
    % {
      Write-Verbose "Found package file $_"
      $spec = [Xml](Get-Content $_)
      $id = $spec.package.metadata.id
      # we need the csproj for the metadata *sigh*
      if ($id -eq '$id$')
      {
        Restore-Nuget
        Push-Location $_.DirectoryName
        $csproj = $_.Name -replace '\.nuspec$', '.csproj'
        # HACK: for this to work, the csproj must have been built already
        Write-Verbose "Building $csproj to retrieve metadata"
        &$script:nuget pack $csproj | Out-Null
        Get-Item *.nupkg |
          Select -ExpandProperty Name -First 1 |
          Select-String -Pattern '^(.*?)\.(\d+.*)\.nupkg$' -AllMatches |
          % {
            $caps = $_.Matches.Captures
            $id = $caps.Groups[1].Value
            $spec.package.metadata.id = $id
            $spec.package.metadata.id = $caps.Groups[2].Value
          }
        Pop-Location
      }
      if ($id -eq '$id$')
      {
        Write-Warning "Could not find id / version for file $_"
        return
      }
      $specs[$id] = @{
        Path = $_
        Definition = $spec
      }
    }

  return $specs
}

function Test-NuGetDependencyPackageVersions
{
<#
.Synopsis
  Will verify that all NuGet packages.config files within a given root
  directory refer to the same version.
.Description
  Very bad things might happen if different parts of your software to
  refer to different versions of dependencies.

  While some software might be resilient to differences in dependency
  version, and some may even require this by design, it's pragmatic to
  expect a single piece of software to rely on a single version of a
  dependency.

  This test is designed to break a build should mismatches occur.

  Packages are listed, sorted by name.
.Parameter Path
  The path fed to Get-ChildItem, that will be used to recurse a given
  directory structure
.Parameter Exclude
  Optional list of string package names to exclude from being considered
  an error.
.Parameter WarnOnly
  Optional switch to use Write-Warning instead of Write-Error
.Example
  Test-NuGetDependencyPackageVersions -Path 'c:\source\myproject'

  Description
  -----------
  Will recursively examine c:\source\myproject, looking for NuGet
  packages.config files.

  If any configuration files are found, where the package versions are
  inconsistent, an error message will be written using Write-Error.
.Example
  Test-NuGetDependencyPackageVersions -Path 'c:\source\myproject'
    -Exclude 'AutoFac' -WarnOnly

  Description
  -----------
  Will recursively examine c:\source\myproject, looking for NuGet
  packages.config files.

  If any configuration files are found, where the package versions are
  inconsistent, excluding any differences with AutoFac, an error message
  will be written using Write-Warning.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    [ValidateScript({ (Get-Item $_).PSIsContainer })]
    $Path,

    [Parameter(Mandatory = $false)]
    [string[]]
    $Exclude = @(),

    [Parameter]
    [switch]
    $WarnOnly
  )

  $packages = Get-NuGetDependencyPackageVersions -Path $Path
  $msgs = @()
  $packages.GetEnumerator() |
    ? { $_.Value.Count -gt 1 } |
    Sort-Object -Property Key |
    % {
      Write-Verbose "Examining package $($_.Key)"
      if ($Exclude -icontains $_.Key) { return }

      $versions = $_.Value
      $msg = "[$($_.Key)] is using $($versions.Count) different versions:`n"
      $versions.GetEnumerator() |
        % {
          $version = $_.Key
          $msg += "`n$version`n`t$($_.Value -join "`n`t")"
        }

      $msgs += " "
      $msgs += $msg
    }

  if ($msgs.Length -eq 0)
  {
    Write-Verbose "All NuGet packages are versioned consistently"
    return
  }

  $msg = "`n" + ($msgs -join "`n`n")
  if ($WarnOnly) { Write-Warning $msg } else { Write-Error $msg }
}

function Get-NuGetDependencyPackageVersions
{
<#
.Synopsis
  Retrieves a list of NuGet packages from all the packages.config files
  within a specified directory.
.Description
  The packages are returned in an Hashtable.

  The hash key is the package name, and the value is a Hashtable
  of found versions.

  The versions hash contains a list of the full file paths where the
  given version is found.
.Parameter Path
  The path fed to Get-ChildItem, that will be used to recurse a given
  directory structure
.Outputs
  A Hashtable of package names and versions, or an empty Hashtable if
  no packages.config files were found.
.Example
  Get-NuGetDependencyPackageVersions -Path 'c:\source\myproject'

  Description
  -----------
  Will recursively examine c:\source\myproject, looking for NuGet
  packages.config files.

  If any configuration files are found, the list of packages is returned
  in a hash.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    [ValidateScript({ (Get-Item $_).PSIsContainer })]
    $Path
  )

  $packages = @{}
  Get-ChildItem -Path $Path -Recurse -Filter 'packages.config' |
    % {
      $fileName = $_.FullName
      Write-Verbose "Examining $fileName"
      $xml = [Xml](Get-Content $fileName)
      if (!$xml.packages.package) { return }
      $xml.packages.package |
        % {
          if (!$packages.ContainsKey($_.id))
            { $packages[$_.id] = @{} }

          $v = $_.version
          if ([string]::IsNullOrEmpty($v)) { $v = 'latest' }

          $pkg = $packages[$_.id]
          if (!$pkg.ContainsKey($v)) { $pkg[$v] = @() }
          if ($pkg[$v] -notcontains $fileName)
          {
            $pkg[$v] += $fileName
          }
        }
    }

  return $packages
}

Export-ModuleMember Test-NuGetDependencyPackageVersions,
  Get-NuGetDependencyPackageVersions, Find-NuGetPackages,
  Get-NuGetPackageSpecs
