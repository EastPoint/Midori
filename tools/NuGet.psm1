$script:nuget = $null

function Get-CurrentDirectory
{
  $thisName = $MyInvocation.MyCommand.Name
  [IO.Path]::GetDirectoryName((Get-Content function:$thisName).File)
}

function Get-NugetPath
{
  if ($script:nuget -and (Test-Path -IsValid $script:nuget) -and `
    (Test-Path $script:nuget))
  {
    return $script:nuget
  }

  $params = @{
    Path = Get-CurrentDirectory;
    Include = 'nuget.exe';
    Recurse = $true;
  }

  $script:nuget = Get-ChildItem @params |
    Select -ExpandProperty FullName -First 1
  return $script:nuget
}

function Restore-Nuget
{
  Write-Verbose 'Restore-Nuget'
  $nuget = Get-NugetPath

  if ($nuget -ne $null)
  {
    &"$nuget" update -Self | Write-Host
    return
  }

  $nugetPath = Join-Path (Get-CurrentDirectory) 'nuget.exe'
  (New-Object Net.WebClient).DownloadFile('http://nuget.org/NuGet.exe', $nugetPath)

  $script:nuget = $nugetPath
}

function Find-NuGetPackages
{
<#
.Synopsis
  Will use the NuGet 'list' command to search for packages of the given
  Name at the given Source (if specified).
.Description
  Nothing fancy here, aside from a light wrapper around Nuget list
  that properly handles generating a search and parsing the results into
  a Hashtable.

  Special treatment is currently given to MyGet feeds specified as a
  source as there is a bug preventing multiple search terms from being
  properly processed on the server.  For a specified MyGet feed, the
  full list is generated by the server, and filtered client-side.

  Note that the MyGet work-around only applies when MyGet is specified
  as the source, not when it is queried implictly based on being
  configured in local sources.

  The client-side is filtered to ensure that the packages returned
  contain the Name(s) specified.
.Parameter Name
  The list of package names to search for in the remote feed.

  Note that the Name is not considered exact, but a substring value.
.Parameter Source
  The remote feed to search against instead of the defaults.

  Note that MyGet is given special treatment if more than one Name is
  specified.
.Example
  Find-NuGetPackages -Name 'CroMagVersion', 'Midori'

  Description
  -----------
  Will search the default Nuget feeds, returning a Hashtable with the
  latest versions of CroMagVersion and Midori.

  May return additional packages based on how the server executes the
  search.
.Example
  Find-NuGetPackages -Name 'CroMagVersion', 'Midori' `
    - 'https://www.myget.org/F/YOURGUID/'

  Description
  -----------
  Will search the given MyGet feed, returning a Hashtable with the
  latest versions of CroMagVersion and Midori should they exist.

  May return additional packages based on how the server executes the
  search.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string[]]
    $Name,

    [Parameter(Mandatory = $false)]
    [string]
    $Source
  )

  Write-Verbose "Find-NuGetPackages retrieving package list from $source..."

  Restore-Nuget

  # TODO: handle -Prerelease
  $listArgs = @()
  if (![string]::IsNullOrEmpty($source)) { $listArgs += '-Source', $source }

  # HACK: myget bug doesn't return search results for multiple pkgs
  # TODO: remove the myget check once they fix their bug
  if ($Name -and ($Name.Length -gt 1) -and ($source -notmatch 'myget\.org'))
    { $listArgs += ($Name -join ', ') }

  $listArgs += '-NonInteractive'

  $list = &$script:nuget list $listArgs
  $packages = @{}
  $list |
    ? { ($_ -notmatch '^(Using credentials)|(No packages)') } |
    % {
      $packageDef = $_ -split '\s'
      $id = $packageDef[0]
      if ($Name)
      {
        $match = $false
        $Name |
          % { if (!$match) { $match = $id -match $_ } }

        if ($match) { $packages.$id = $packageDef[1] }
      }
    }

  Write-Host "Found $($packages.Count) packages at $source"
  return $packages
}

function Test-NuGetDependencyPackageVersions
{
<#
.Synopsis
  Will verify that all NuGet packages.config files within a given root
  directory refer to the same version.
.Description
  Very bad things might happen if different parts of your software to
  refer to different versions of dependencies.

  While some software might be resilient to differences in dependency
  version, and some may even require this by design, it's pragmatic to
  expect a single piece of software to rely on a single version of a
  dependency.

  This test is designed to break a build should mismatches occur.

  Packages are listed, sorted by name.
.Parameter Path
  The path fed to Get-ChildItem, that will be used to recurse a given
  directory structure
.Parameter Exclude
  Optional list of string package names to exclude from being considered
  an error.
.Parameter WarnOnly
  Optional switch to use Write-Warning instead of Write-Error
.Example
  Test-NuGetDependencyPackageVersions -Path 'c:\source\myproject'

  Description
  -----------
  Will recursively examine c:\source\myproject, looking for NuGet
  packages.config files.

  If any configuration files are found, where the package versions are
  inconsistent, an error message will be written using Write-Error.
.Example
  Test-NuGetDependencyPackageVersions -Path 'c:\source\myproject'
    -Exclude 'AutoFac' -WarnOnly

  Description
  -----------
  Will recursively examine c:\source\myproject, looking for NuGet
  packages.config files.

  If any configuration files are found, where the package versions are
  inconsistent, excluding any differences with AutoFac, an error message
  will be written using Write-Warning.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    [ValidateScript({ (Get-Item $_).PSIsContainer })]
    $Path,

    [Parameter(Mandatory = $false)]
    [string[]]
    $Exclude = @(),

    [Parameter]
    [switch]
    $WarnOnly
  )

  $packages = Get-NuGetDependencyPackageVersions -Path $Path
  $msgs = @()
  $packages.GetEnumerator() |
    ? { $_.Value.Count -gt 1 } |
    Sort-Object -Property Key |
    % {
      Write-Verbose "Examining package $($_.Key)"
      if ($Exclude -icontains $_.Key) { return }

      $versions = $_.Value
      $msg = "[$($_.Key)] is using $($versions.Count) different versions:`n"
      $versions.GetEnumerator() |
        % {
          $version = $_.Key
          $msg += "`n$version`n`t$($_.Value -join "`n`t")"
        }

      $msgs += " "
      $msgs += $msg
    }

  if ($msgs.Length -eq 0)
  {
    Write-Verbose "All NuGet packages are versioned consistently"
    return
  }

  $msg = "`n" + ($msgs -join "`n`n")
  if ($WarnOnly) { Write-Warning $msg } else { Write-Error $msg }
}

function Get-NuGetDependencyPackageVersions
{
<#
.Synopsis
  Retrieves a list of NuGet packages from all the packages.config files
  within a specified directory.
.Description
  The packages are returned in an Hashtable.

  The hash key is the package name, and the value is a Hashtable
  of found versions.

  The versions hash contains a list of the full file paths where the
  given version is found.
.Parameter Path
  The path fed to Get-ChildItem, that will be used to recurse a given
  directory structure
.Outputs
  A Hashtable of package names and versions, or an empty Hashtable if
  no packages.config files were found.
.Example
  Get-NuGetDependencyPackageVersions -Path 'c:\source\myproject'

  Description
  -----------
  Will recursively examine c:\source\myproject, looking for NuGet
  packages.config files.

  If any configuration files are found, the list of packages is returned
  in a hash.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    [ValidateScript({ (Get-Item $_).PSIsContainer })]
    $Path
  )

  $packages = @{}
  Get-ChildItem -Path $Path -Recurse -Filter 'packages.config' |
    % {
      $fileName = $_.FullName
      Write-Verbose "Examining $fileName"
      $xml = [Xml](Get-Content $fileName)
      if (!$xml.packages.package) { return }
      $xml.packages.package |
        % {
          if (!$packages.ContainsKey($_.id))
            { $packages[$_.id] = @{} }

          $v = $_.version
          if ([string]::IsNullOrEmpty($v)) { $v = 'latest' }

          $pkg = $packages[$_.id]
          if (!$pkg.ContainsKey($v)) { $pkg[$v] = @() }
          if ($pkg[$v] -notcontains $fileName)
          {
            $pkg[$v] += $fileName
          }
        }
    }

  return $packages
}

Export-ModuleMember Test-NuGetDependencyPackageVersions,
  Get-NuGetDependencyPackageVersions, Find-NuGetPackages
